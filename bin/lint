#!/usr/bin/env bash

set -e

function _linter_flay {
  echo "[ bin/lint ] üïµÔ∏è  flay: Analyzing Ruby code duplication."
  bin/flay
}

function _linter_reek {
  echo "[ bin/lint ] üïµÔ∏è  reek: Analyzing Ruby code for code smells."
  bin/reek --single-line --sort-by smelliness
}

function _linter_standardrb {
  echo "[ bin/lint ] üïµÔ∏è  standardrb (rubocop): Analyzing Ruby code for style and convention offences."
  bin/standardrb
}

function _linter_pronto_local {
  echo "[ bin/lint ] üïµÔ∏è  pronto: Running pronto with text formatter (locally, including unstaged changes) and failing the script in case of error messages..."
  bin/pronto run --commit origin/main --staged --unstaged --formatters text --exit-code
}

function lint_local_topic_branch {
  # Workaround to be able to use pronto even with untracked file changes. We
  # first stage everything, run pronto, and then undo the staging.
  git add --all &> /dev/null
  set +e
  _linter_pronto_local
  set -e
  git reset &> /dev/null
}

function lint_local_main_branch {
  _linter_standardrb
  _linter_reek
  _linter_flay
}

echo "[ bin/lint ] ‚ÑπÔ∏è  Running on developer machine."
if [ "$(git rev-parse --abbrev-ref HEAD)" == "main" ] || [ "$(git branch --show-current)" == "main" ]; then
  echo "[ bin/lint ] ‚ÑπÔ∏è  Running on 'main' branch."
  lint_local_main_branch
else
  if [ "$1" == "--all" ] || [ "$1" == "-a" ]; then
    echo "[ bin/lint ] ‚ÑπÔ∏è  Running on a topic branch, but analyzing all files (as requested by '$1')."
    lint_local_main_branch
  else
    echo "[ bin/lint ] ‚ÑπÔ∏è  Running on a topic branch, analyzing changes to 'main' only."
    lint_local_topic_branch
  fi
fi

echo "[ bin/lint ] üèÅ  Done"
